GTRenderer
----------

GTRenderer renderer is the reason why you signed up for this whole GeoTools experience; you want to see a Map.

GTRenderer is actually an interface; currently there are two implementations:

* StreamingRenderer - a great implementation that does not cache anything. This decision makes it easier to understand and allows it to tackle that large datasets without running out of memory.
* ShapefileRenderer - (unsupported) restricted to shapefiles as a playground for trying out speed improvements. However all the good optimisations have been picked up by StreamingRenderer.


.. image:: /images/GTRenderer.PNG

We should get around to moving this interface to gt-api, it just has not been done yet.

Drawing
^^^^^^^

How to drawn an outputArea rectangle::
  
  GTRenderer draw = new StreamingRenderer();
  draw.setContext(map);
  
  draw.paint(g2d, outputArea, map.getLayerBounds() );

If you have completed the Quickstart, this is the approach used by the JMapPane class we use in a lot of our tutorials.

Graphics2D
''''''''''

The important part of the above example is that GTRenderer works on the Java2D class **Graphics2D**. You can find many implementations of Graphics2D allowing GeoTools to work with a range of graphics systems beyond simply the screen.

* Swing JComponent
  
  You can create a swing control to render the image interactively; we
  provide an example JMapPane for use in our tutorials.
  
  GTRenderer is just a rendering engine - in your own application you may
  consider the following ideas:
  
  * Experiment with different Java 2D graphics settings such as
    anti-aliasing
  * Use background threads to draw tiles, and allowing your swing control
    to pull the tiles onto the screen for a smooth "slippy" map

* 3D
  
  A google summer of code student put together and example of rendering
  into a texture buffers and using OpenGL to handle panning and zooming.
  
  Personally I would look for an Graphics2D implementation that was
  backed by OpenGL commands and use GeoTools to render out into the scene
  graph.
  
  If you are interested in the students code it is currently in the
  "spike" directory of GeoTools where we keep experiments.

* Printing
  
  You can print using StreamingRenderer, the code works like normal just
  use the Graphics2D object from your Printer.
  
  uDig uses this facility to allow for printing maps directly to the
  printer.

* PDF
  
  We have also had success using GTRenderer and Batik for the generation
  of PDF output (they provide a Graphics2D object).

  You can see this functionality in uDig and GeoServer.
  
  The following example is taken from uDig::
    
    Rectangle suggestedPageSize = getITextPageSize(page1.getPageSize());                
    Rectangle pageSize = rotatePageIfNecessary(suggestedPageSize);
    //rotate if we need landscape
    Document document = new Document(pageSize);  
    ...
    PdfWriter writer = PdfWriter.getInstance(document, new FileOutputStream(outputFile));
    document.open();            
    Graphics2D graphics = cb.createGraphics(pageSize.getWidth(), pageSize.getHeight());
    
    // call your GTRenderer here
    GTRenderer draw = new StreamingRenderer();
    draw.setContext(map);
    
    draw.paint(graphics, outputArea, map.getLayerBounds() );
    
    // cleanup
    graphics.dispose();
    
    //cleanup
    document.close();
    writer.close();
  
  PDF Tips:
  
  You may wish to increase the page size by 2 and then scale the result by 50% in order to produce high resolution raster layers

* SVG
  
   Other teams have used the Batik project to generate SVG output.
   
   Thanks to James Macgill for the following code example: GenerateSVG.java

Image Export
^^^^^^^^^^^^

Here is an example from Oliver on the email list::
  
  public void saveImage(MapContext map, String file){ 
  
    GTRenderer renderer = new StreamingRenderer();
    renderer.setContext( map );
    
    Rectangle imageBounds=null;
    try{
        ReferencedEnvelope mapBounds=map.getLayerBounds();

        double heightToWidth = mapBounds.getSpan(1) / mapBounds.getSpan(0);
        int imageWidth = 600;

        imageBounds = new Rectangle(
                0, 0, imageWidth, (int) Math.round(imageWidth * heightToWidth));
    }catch(Exception e){
        
    } 
    
    //Rectangle imageSize = new Rectangle(600,600);
    
    BufferedImage image = new BufferedImage(imageBounds.width, imageBounds.height,      BufferedImage.TYPE_INT_RGB); //darker red fill

    Graphics2D gr = image.createGraphics();
    gr.setPaint(Color.WHITE);
    gr.fill(imageBounds);
    
    try {
        renderer.paint(gr, imageBounds, map.getAreaOfInterest());
  
        
        File fileToSave = new File(file);
        ImageIO.write(image, "jpeg", fileToSave);
    }catch(IOException e){
        
    }    
  }

Note the above example depends on the map area of interest having the same aspect ratio as the imageSize. You can calculate this yourself; or there may be a helper method in ScaleUtils.
