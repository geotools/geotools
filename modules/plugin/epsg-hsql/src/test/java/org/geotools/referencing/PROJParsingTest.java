/*
 *    GeoTools - The Open Source Java GIS Toolkit
 *    http://geotools.org
 *
 *    (C) 2024, Open Source Geospatial Foundation (OSGeo)
 *
 *    This library is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU Lesser General Public
 *    License as published by the Free Software Foundation;
 *    version 2.1 of the License.
 *
 *    This library is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *    Lesser General Public License for more details.
 */
package org.geotools.referencing;

import static org.junit.Assert.assertTrue;

import java.io.BufferedWriter;
import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
import org.geotools.api.referencing.FactoryException;
import org.geotools.api.referencing.crs.CoordinateReferenceSystem;
import org.geotools.api.referencing.crs.GeographicCRS;
import org.geotools.api.referencing.crs.ProjectedCRS;
import org.geotools.referencing.proj.PROJFormattable;
import org.geotools.referencing.proj.PROJFormatter;
import org.geotools.test.TestData;
import org.junit.Ignore;
import org.junit.Test;

public class PROJParsingTest {

    /**
     * Test used to create the definition files. Keep ignoring-it unless you need to generate the definition files again
     * and validate it using the gt_proj_compare.py script
     */
    @SuppressWarnings("PMD.SystemPrintln")
    @Test
    @Ignore
    public void testGeneratePROJDefinitions() throws IOException {
        Path tempCSVFile = Files.createTempFile("gt_proj_definitions", ".csv");
        Path tempPropertiesFile = Files.createTempFile("gt_proj_definitions", ".properties");

        PROJFormatter formatter = new PROJFormatter();
        try (BufferedWriter csvWriter = Files.newBufferedWriter(tempCSVFile);
                PrintWriter writer = new PrintWriter(csvWriter);
                BufferedWriter propertiesWriter = Files.newBufferedWriter(tempPropertiesFile);
                PrintWriter pWriter = new PrintWriter(propertiesWriter)) {
            // Write CSV headers
            writer.println("EPSG Code,PROJ Definition");
            // Iterate over EPSG codes
            for (int epsgCode = 1; epsgCode <= 100000; epsgCode++) {
                formatter.clear();
                String epsgCodeString = "EPSG:" + epsgCode;
                try {
                    // Get the CRS from EPSG code
                    CoordinateReferenceSystem crs = CRS.decode(epsgCodeString);
                    String projString;
                    if (crs instanceof PROJFormattable formattable) {
                        projString = formatter.toPROJ(formattable);
                        writer.printf("%d,%s%n", epsgCode, projString);
                        pWriter.printf("%d=%s%n", epsgCode, projString);
                    }

                } catch (FactoryException e) {
                    // There are several EPSG code that fail on CRS.decode
                    // even before being formatted as PROJ. Ignore them
                }
            }
        }
        System.out.println("CSV file:" + tempCSVFile);
        System.out.println("Properties file:" + tempPropertiesFile);
    }

    /**
     * Load the supported EPSG Proj Definitions and get the PROJ String from each EPSG code. Check that what is being
     * generated matches what is expected
     */
    @Test
    public void testExtensivePROJDefinitions() throws IOException, FactoryException {
        // proj_definitions have been generated by the
        // testGeneratePROJDefinitions Ignored test
        TestData.unzipFile(this, "gt_proj_definitions.zip");
        File propFile = TestData.file(this, "gt_proj_definitions.properties");
        Properties projDefinitions = new Properties();
        projDefinitions.load(Files.newInputStream(propFile.toPath()));
        PROJFormatter formatter = new PROJFormatter();
        for (String epsgCode : projDefinitions.stringPropertyNames()) {
            formatter.clear();
            String expectedProjString = projDefinitions.getProperty(epsgCode);

            CoordinateReferenceSystem crs = CRS.decode("EPSG:" + epsgCode);
            String decodedProjString = formatter.toPROJ((PROJFormattable) crs);

            assertTrue(
                    "Mismatch for EPSG code: "
                            + epsgCode
                            + "\nexpected="
                            + expectedProjString
                            + " \nactual="
                            + decodedProjString,
                    assertProjStringEquality(expectedProjString, decodedProjString, 1E-6));
        }
        propFile.deleteOnExit();
    }

    /**
     * Compares two PROJ strings with a tolerance for numeric values.
     *
     * @param expected the expected PROJ string.
     * @param actual the actual PROJ string.
     * @param delta the maximum allowable difference between numeric values.
     * @return true if the strings match within the tolerance, false otherwise.
     */
    public static boolean assertProjStringEquality(String expected, String actual, double delta) {
        Map<String, String> expectedMap = parseProjString(expected);
        Map<String, String> actualMap = parseProjString(actual);

        // Check each entry in expectedMap
        for (String key : expectedMap.keySet()) {
            String expectedValue = expectedMap.get(key);
            String actualValue = actualMap.get(key);

            // If the actual map lacks a key from the expected map, strings don't match
            if (actualValue == null) {
                return false;
            }

            // Try parsing both as doubles; if successful, compare with tolerance
            try {
                double expectedDouble = Double.parseDouble(expectedValue);
                double actualDouble = Double.parseDouble(actualValue);
                if (Math.abs(expectedDouble - actualDouble) > delta) {
                    return false; // Numeric difference exceeds tolerance
                }
            } catch (NumberFormatException e) {
                // Not a numeric value, compare as strings
                if (!expectedValue.equals(actualValue)) {
                    return false;
                }
            }
        }

        // Check for extra keys in actualMap that weren't in expectedMap
        for (String key : actualMap.keySet()) {
            if (!expectedMap.containsKey(key)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Parses a PROJ string into a map of keys and values.
     *
     * @param projString the PROJ string to parse.
     * @return a map with each parameter as a key-value pair.
     */
    private static Map<String, String> parseProjString(String projString) {
        Map<String, String> map = new HashMap<>();

        // Split on spaces to get individual "+key=value" or "+key" components
        String[] components = projString.trim().split("\\s+");
        for (String component : components) {
            if (component.startsWith("+")) {
                String[] keyValue = component.substring(1).split("=", 2); // Split on first "=" only
                String key = keyValue[0];
                String value = keyValue.length > 1 ? keyValue[1] : "";
                map.put(key, value);
            }
        }

        return map;
    }

    @Test
    public void testProjectedCRS() throws FactoryException {
        PROJFormatter formatter = new PROJFormatter();
        CoordinateReferenceSystem crs = CRS.decode("EPSG:32632");
        assertTrue(crs instanceof ProjectedCRS);
        String decodedProjString = formatter.toPROJ((PROJFormattable) crs);
        assertTrue(decodedProjString.contains("+proj=tmerc"));
        assertTrue(decodedProjString.contains("+lon_0=9"));
        assertTrue(decodedProjString.contains("+k=0.9996"));
    }

    @Test
    public void testGeographicCRS() throws FactoryException {
        PROJFormatter formatter = new PROJFormatter();
        CoordinateReferenceSystem crs = CRS.decode("EPSG:4326");
        assertTrue(crs instanceof GeographicCRS);
        String decodedProjString = formatter.toPROJ((PROJFormattable) crs);
        assertTrue(decodedProjString.contains("+proj=longlat"));
        assertTrue(decodedProjString.contains("+datum=WGS84"));
    }
}
